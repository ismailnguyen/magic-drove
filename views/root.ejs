<p class="text-lg font-medium">Folder: <strong><%= rootFolder %></strong></p>
<table class="table-auto w-full border-collapse border border-gray-200 mt-4">
    <thead>
        <tr class="bg-gray-100">
            <th class="border border-gray-300 px-4 py-2">File Name</th>
            <th class="border border-gray-300 px-4 py-2">Tags</th>
            <th class="border border-gray-300 px-4 py-2">Action</th>
            <th class="border border-gray-300 px-4 py-2">Best Match Folders</th>
        </tr>
    </thead>
    <tbody>
        <% files.forEach(file => { %>
            <tr class="odd:bg-white even:bg-gray-50">
                <td class="border border-gray-300 px-4 py-2" data-file="<%= file.fileName %>">
                    <span><%= file.fileName %></span>
                    <!-- Copy to Clipboard Icon -->
                    <a href="#" class="text-blue-500 hover:text-blue-700 ml-4 copy-file-path"
                        data-file-path="<%= path.join(rootFolder, file.fileName) %>">
                        <i class="fas fa-copy"></i>
                    </a>
                    <!-- Edit Icon -->
                    <a href="#" class="text-blue-500 hover:text-blue-700 ml-4 edit-filename"
                        data-file="<%= file.fileName %>">
                        <i class="fas fa-edit"></i>
                    </a>
                </td>
                <td class="border border-gray-300 px-4 py-2 relative">
                    <div class="flex items-center">
                        <input 
                            type="text" 
                            class="tags-input w-full border border-gray-300 px-2 py-1 rounded" 
                            placeholder="Add tags separated by commas" 
                            data-file="<%= file.fileName %>">
                        <button 
                            class="magic-wand-btn text-blue-500 hover:text-blue-700 ml-2"
                            data-file="<%= file.fileName %>">
                            <i class="fas fa-magic"></i>
                        </button>
                    </div>
                </td>
                <td class="border border-gray-300 px-4 py-2">
                    <button class="find-folders-btn bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                        data-file="<%= file.fileName %>">
                        Find folders
                    </button>
                </td>
                <td class="border border-gray-300 px-4 py-2">
                    <ul class="matching-folders space-y-2" data-file="<%= file.fileName %>"></ul>
                </td>
            </tr>
        <% }); %>
    </tbody>
</table>

<script>
    document.querySelectorAll('.tags-input').forEach(input => {
        const measureSpan = document.createElement('span'); // Hidden span to measure text width
        measureSpan.style.position = 'absolute';
        measureSpan.style.visibility = 'hidden';
        measureSpan.style.whiteSpace = 'pre';
        document.body.appendChild(measureSpan);
    
        const adjustWidth = () => {
            measureSpan.textContent = input.value || input.placeholder; // Use placeholder if empty
            input.style.width = `${measureSpan.offsetWidth + 20}px`; // Add padding
        };
    
        // Adjust width on input and focus events
        input.addEventListener('input', adjustWidth);
        input.addEventListener('focus', adjustWidth);
    
        // Initialize width
        adjustWidth();
    });

    document.querySelectorAll('.tags-input').forEach(input => {
        const autocompleteContainer = document.createElement('ul');
        autocompleteContainer.className = 'autocomplete-dropdown absolute bg-white border border-gray-300 rounded shadow-lg w-full max-h-40 overflow-y-auto hidden';
        input.parentElement.appendChild(autocompleteContainer);
    
        input.addEventListener('input', (event) => {
            const fileName = input.getAttribute('data-file');
            const searchText = input.value.trim().toLowerCase();
    
            // Clear the dropdown if the input is empty
            if (!searchText) {
                autocompleteContainer.innerHTML = '';
                autocompleteContainer.classList.add('hidden');
                return;
            }
    
            // Extract base words from the file name (by splitting filename by underscores (_) and spaces)
            const baseName = fileName.split('.').slice(0, -1).join('.'); // Remove extension
            const parts = baseName.split(/[_\s]+/).map(part => {
                if (/^\d{8}$/.test(part)) {
                    return part.slice(0, 4); // Extract year from YYYYMMDD
                }
                return part;
            });
    
            // Filter matching parts based on the input
            const matches = parts.filter(part => part.toLowerCase().includes(searchText));
    
            // Update the dropdown with matching results
            autocompleteContainer.innerHTML = matches
                .map(match => `<li class="p-2 hover:bg-blue-100 cursor-pointer">${match}</li>`)
                .join('');
            autocompleteContainer.classList.remove('hidden');
    
            // Add click listener for each match
            autocompleteContainer.querySelectorAll('li').forEach(item => {
                item.addEventListener('click', () => {
                    const currentTags = input.value.split(',').map(tag => tag.trim());
                    const selectedTag = item.textContent;
    
                    // Replace the last incomplete word with the selected tag
                    const lastWordIndex = currentTags.findIndex(tag => tag.toLowerCase().includes(searchText));
                    if (lastWordIndex !== -1) {
                        currentTags[lastWordIndex] = selectedTag;
                    } else {
                        currentTags.push(selectedTag);
                    }
    
                    // Update the input and clear the dropdown
                    input.value = currentTags.filter(Boolean).join(', ');
                    autocompleteContainer.innerHTML = '';
                    autocompleteContainer.classList.add('hidden');
                });
            });
        });
    
        // Hide the dropdown if the user clicks outside
        document.addEventListener('click', (event) => {
            if (!input.contains(event.target) && !autocompleteContainer.contains(event.target)) {
                autocompleteContainer.classList.add('hidden');
            }
        });
    });

    // Function to generate tags using the Magic Wand
    async function generateTags(fileName, inputField, callback) {
        if (!fileName) return;

        // Save the original placeholder to restore later
        const originalPlaceholder = inputField.placeholder;

        // Update the placeholder to indicate loading
        inputField.placeholder = 'Loading tags...';
    
        // Extract base words from the file name (by splitting filename by underscores (_) and spaces)
        const baseName = fileName.split('.').slice(0, -1).join('.'); // Remove extension
        const parts = baseName.split(/[_\s]+/).map(part => {
            if (/^\d{8}$/.test(part)) {
                return part.slice(0, 4); // Extract year from YYYYMMDD
            }
            return part;
        });

        try {
            // Send the extracted parts as tags to match folders
            const response = await fetch('/match-folders', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fileName, tags: parts }),
            });
            const data = await response.json();

            if (data.success && data.folders.length > 0) {
                // Collect all folder paths
                const folderPaths = data.folders.map(folder => folder.toLowerCase());

                // Filter parts that match any folder path
                const matchingTags = parts.filter(part =>
                    folderPaths.some(folderPath => folderPath.includes(part.toLowerCase()))
                );

                // Update the tags input
                const currentTags = inputField.value.split(',').map(tag => tag.trim()).filter(Boolean);
                const updatedTags = [...new Set([...currentTags, ...matchingTags])]; // Avoid duplicates
                inputField.value = updatedTags.join(', '); // Ensure proper comma-separated format

                // Call the callback after tags are updated
                if (callback) {
                    callback(updatedTags);
                }
            } else {
                showToast('No matching folders found for the magic wand.', 'error');
            }
        } catch (error) {
            console.error('Error fetching matching folders:', error);
            showToast('An error occurred while using the magic wand.', 'error');
        }

        // Restore the original placeholder
        inputField.placeholder = originalPlaceholder;
    }

    // Auto-fill tags input with words from the file name
    document.querySelectorAll('.magic-wand-btn').forEach(button => {
        button.addEventListener('click', async (event) => {
            event.preventDefault();
    
            const fileName = event.target.closest('button').getAttribute('data-file');
            const inputField = document.querySelector(`.tags-input[data-file="${fileName}"]`);
    
            await generateTags(fileName, inputField, null);
        });
    });

    // Copy file path to clipboard
    document.querySelectorAll('.copy-file-path').forEach(link => {
        link.addEventListener('click', (event) => {
            event.preventDefault();
            const filePath = event.target.closest('a').getAttribute('data-file-path');
            navigator.clipboard.writeText(filePath)
                .then(() => {
                    showToast(`File path "${filePath}" copied to clipboard.`);
                })
                .catch(err => {
                    console.error('Error copying to clipboard:', err);
                    showToast('Failed to copy the file path to clipboard.', 'error');
                });
        });
    });

    // Scroll to a specific file row on page load if a hash is present
    if (window.location.hash) {
        const hash = window.location.hash.substring(1);
        const element = document.getElementById(hash);
        if (element) element.scrollIntoView({ behavior: 'smooth' });
    }

    // Handle editing the file name
    document.querySelectorAll('.edit-filename').forEach(link => {
        link.addEventListener('click', async (event) => {
            event.preventDefault();
            const fileName = event.target.closest('a').getAttribute('data-file');
            const newFileName = prompt(`Enter the new name for the file "${fileName}":`, fileName);

            if (newFileName && newFileName.trim() !== '' && newFileName !== fileName) {
                try {
                    const response = await fetch('/rename-file', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ oldFileName: fileName, newFileName: newFileName.trim() }),
                    });
                    const data = await response.json();
                    if (data.success) {
                        // Refresh page and scroll to the updated file
                        window.location.hash = `file-${newFileName.replace(/\W/g, '_')}`;
                        window.location.reload();
                    } else {
                        showToast(data.message || 'Failed to rename the file.');
                    }
                }
                catch(err) {
                    console.error('Error:', err);
                    showToast('An error occurred while renaming the file.', 'error');
                }
            }
        });
    });
    
    // Function to find folders based on tags
    async function findFolders(fileName, tags, inputField, matchingFoldersElement, fileNameCell, tagsCell) {
        // Add a loading placeholder
        matchingFoldersElement.innerHTML = '<div class="text-gray-500">Looking for best matching folders...</div>';
            
        // Move the file name, tags input, and magic wand button to the top
        fileNameCell.style.verticalAlign = 'top';
        tagsCell.style.verticalAlign = 'top';

        try {
            const response = await fetch(`/match-folders`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fileName, tags }),
            });

            const data = await response.json();
    
            matchingFoldersElement.innerHTML = ''; // Clear previous matches

            if (data.success && data.folders.length > 0) {
                data.folders.forEach(folder => {
                    const li = document.createElement('li');

                    // Highlight folders in the path based on full or partial matches with tags longer than 2 characters
                    const highlightedPath = folder.split('/').map(part => {
                        const lowerPart = part.toLowerCase();

                        // Filter tags specifically for highlighting
                        const highlightTags = tags.filter(tag => tag.length > 2);

                        // Check if any highlight-eligible tag matches fully or partially
                        const isMatch = highlightTags.some(tag => {
                            const normalizedTag = tag.replace(/[-_\s]+/g, ''); // Normalize tags
                            const normalizedPart = lowerPart.replace(/[-_\s]+/g, ''); // Normalize folder names
                            return normalizedPart.includes(normalizedTag);
                        });

                        // Highlight the folder if it matches
                        if (isMatch) {
                            return `<span class="bg-yellow-200 font-bold">${part}</span>`;
                        }
                        return part;
                    }).join('/');

                    li.innerHTML = highlightedPath;

                    // Add folder name
                    const folderNameSpan = document.createElement('span');
                    folderNameSpan.textContent = folder;

                    // Add "Copy Path" link for the folder
                    const copyFolderPathLink = document.createElement('a');
                    copyFolderPathLink.href = '#';
                    copyFolderPathLink.innerHTML = '<i class="fas fa-copy text-blue-500 hover:text-blue-700 ml-4"></i>';
                    copyFolderPathLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        navigator.clipboard.writeText(folder)
                            .then(() => {
                                showToast(`Folder path "${folder}" copied to clipboard.`);
                            })
                            .catch(err => {
                                console.error('Error copying to clipboard:', err);
                                showToast('Failed to copy the folder path to clipboard.');
                            });
                    });

                    // Add "Move File" link
                    const moveLink = document.createElement('a');
                    moveLink.href = '#';
                    moveLink.innerHTML = '<i class="fas fa-folder-open"></i>';
                    moveLink.className = 'text-blue-500 hover:text-blue-700 ml-4';
                    moveLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        try {
                            const moveResponse = fetch(`/move-file`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ fileName, destination: folder }),
                            });

                            const moveData = moveResponse.json();

                            if (moveData.success) {
                                showToast(`File "${fileName}" moved to "${folder}" successfully.`);
                                window.location.reload(); // Refresh the page after success
                            } else {
                                showToast(`Failed to move file "${fileName}" to "${folder}".`);
                            }
                        }
                        catch(err) {
                            console.error('Error:', err);
                            showToast('An error occurred while moving the file.');
                        }
                    });

                    li.appendChild(copyFolderPathLink);
                    li.appendChild(moveLink);
                    matchingFoldersElement.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'No matching folders found.';
                matchingFoldersElement.appendChild(li);
            }
        }
        catch(err) {
            console.error('Error:', err);
            matchingFoldersElement.innerHTML = '<div class="text-red-500">An error occurred. Please try again.</div>';
        }
    }

    document.querySelectorAll('.find-folders-btn').forEach(button => {
        button.addEventListener('click', async (event) => {
            const fileName = event.target.getAttribute('data-file');
            const inputField = document.querySelector(`.tags-input[data-file="${fileName}"]`);
            const matchingFoldersElement = document.querySelector(`.matching-folders[data-file="${fileName}"]`);
            const fileNameCell = document.querySelector(`td[data-file="${fileName}"]`);
            const tagsCell = inputField.closest('td'); // Tags cell container
    
            // If the tags input is empty, generate tags first
            if (!inputField.value.trim()) {
                showToast('Tags are empty. Automatically generating tags...', 'info');
                await generateTags(fileName, inputField, async (foundTags) => {
                    await findFolders(fileName, foundTags, inputField, matchingFoldersElement, fileNameCell, tagsCell);
                });
            } else {
                const tags = inputField.value
                        .split(',')
                        .map(tag => tag.trim().toLowerCase()) // Normalize tags to lowercase
                        .filter(tag => tag); // Keep all tags for general operations

                await findFolders(fileName, tags, inputField, matchingFoldersElement, fileNameCell, tagsCell);
            }
        });
    });
</script>